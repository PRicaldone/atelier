/**
 * ðŸŒ± BIFLOW DATA MODEL - Board â†” Mind Garden 1:1 Relationship
 * 
 * ðŸš¨ POLICY: All code, data models, UX/UI flows and architecture
 * MUST comply with the single specification at /docs/BIFLOW-COMPLETE-TYPES.md (current version: v2.0.1).
 * In case of any doubt or discrepancy between code, comments, chat, or other docs,
 * the latest version of this document ALWAYS TAKES PRECEDENCE.
 * No structural changes may be made without reviewing and updating the spec.
 * 
 * This module defines the extended data structures required for the
 * bidirectional flow between Scriptorium boards and Mind Garden spaces.
 * 
 * CORE PRINCIPLE: Every Board MUST have a Mind Garden, every Mind Garden MUST have a Board
 */

import { ELEMENT_TYPES, createCanvasElement } from './types.js';

// ðŸŒ± BIFLOW: Origin tracking constants
export const BIFLOW_ORIGINS = {
  // Board origins
  MIND_GARDEN_GENERAL: 'MG-generale', // Promoted from general Mind Garden
  MANUAL: 'manual',                   // Created manually by user
  AI_GENERATED: 'ai',                 // Generated by AI assistant
  SUB_BOARD: 'sub-board',            // Created from parent board
  DUPLICATED: 'duplicated',          // Duplicated from existing board
  IMPORTED: 'imported',              // Imported from external source
  
  // Mind Garden origins
  GENERAL: 'general',                // SPECIAL: The root general Mind Garden (no board)
  PROMOTED: 'promoted',              // Created when board was promoted from ideas
  DEDICATED: 'dedicated',            // Created as dedicated garden for board
  SUB_GARDEN: 'sub-garden',         // Created for sub-board
  MIGRATED: 'migrated'              // Migrated from legacy board without garden
};

// ðŸŽ¯ FREESTYLE TO PROJECT: Mode constants
export const CREATIVE_MODES = {
  FREESTYLE: 'freestyle',           // Free exploration, no commitment
  PROJECT: 'project'                // Formal project with metadata
};

// ðŸŒ± BIFLOW: Special constants for General Mind Garden
export const GENERAL_MIND_GARDEN = {
  ID: 'general',
  TITLE: 'Mind Garden Generale',
  DESCRIPTION: 'The root creative space where all ideas begin'
};

// ðŸŒ± BIFLOW: Extended Board data structure
export const createBiFlowBoard = (type = ELEMENT_TYPES.BOARD, position = { x: 0, y: 0 }, options = {}) => {
  const baseBoard = createCanvasElement(type, position);
  
  // ðŸš¨ CRITICAL: Extend board with BiFlow properties
  const biflowBoard = {
    ...baseBoard,
    
    // ðŸŒ± MANDATORY: Mind Garden relationship (NEVER null)
    mindGardenId: null, // Will be set during creation process
    
    // ðŸŒ± ORIGIN TRACKING: Where this board came from
    origin: options.origin || BIFLOW_ORIGINS.MANUAL,
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Creative mode
    mode: options.mode || CREATIVE_MODES.FREESTYLE, // Always start as freestyle
    
    // ðŸŒ± HIERARCHY: Parent relationship for sub-boards
    parentBoardId: options.parentBoardId || null,
    
    // ðŸŒ± TIMESTAMPS: BiFlow lifecycle tracking
    biflowCreatedAt: Date.now(),
    biflowUpdatedAt: Date.now(),
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Project metadata (only when mode="project")
    project: options.mode === CREATIVE_MODES.PROJECT ? {
      name: options.projectName || null,
      description: options.projectDescription || null,
      tags: options.projectTags || [],
      deadline: options.projectDeadline || null,
      collaborators: options.projectCollaborators || [],
      status: options.projectStatus || 'active', // active, paused, completed
      priority: options.projectPriority || 'medium' // low, medium, high
    } : null,
    
    // ðŸŒ± METADATA: Additional BiFlow properties
    biflowMetadata: {
      // Original promotion context (if promoted from Mind Garden)
      promotionContext: options.promotionContext || null,
      
      // Elements that were promoted to create this board
      promotedElementIds: options.promotedElementIds || [],
      
      // Source garden ID if promoted from specific garden
      sourceGardenId: options.sourceGardenId || null,
      
      // Auto-generated title from promoted elements
      autoGeneratedTitle: options.autoGeneratedTitle || null,
      
      // BiFlow generation number (0 = original, 1+ = sub-boards)
      generation: options.generation || 0
    },
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Promotion history tracking
    promotionHistory: [
      {
        action: 'created_as_freestyle',
        timestamp: Date.now(),
        mode: options.mode || CREATIVE_MODES.FREESTYLE
      }
    ]
  };
  
  return biflowBoard;
};

// ðŸŒ± BIFLOW: Mind Garden data structure
export const createMindGarden = (boardId, options = {}) => {
  return {
    // Core identity
    id: `mg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    
    // ðŸš¨ MANDATORY: Board relationship (NEVER null - EXCEPT for General Mind Garden)
    boardId: boardId, // null ONLY allowed for General Mind Garden (id: 'general')
    
    // ðŸŒ± ORIGIN TRACKING: How this garden was created
    origin: options.origin || BIFLOW_ORIGINS.DEDICATED,
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Creative mode
    mode: options.mode || CREATIVE_MODES.FREESTYLE, // Always start as freestyle
    
    // ðŸŒ± HIERARCHY: Parent relationship for sub-gardens
    parentGardenId: options.parentGardenId || null,
    
    // ðŸŒ± CONTENT: Mind Garden elements (ideas, nodes, connections)
    elements: options.elements || [],
    
    // ðŸŒ± LAYOUT: Mind Garden specific layout data
    layout: {
      // ReactFlow or custom layout engine data
      nodes: options.nodes || [],
      edges: options.edges || [],
      viewport: options.viewport || { x: 0, y: 0, zoom: 1 },
      
      // Layout algorithm preferences
      layoutType: options.layoutType || 'organic', // organic, hierarchical, force, grid
      autoLayout: options.autoLayout !== false, // Auto-arrange new nodes
      
      // Visual preferences
      theme: options.theme || 'default',
      colorScheme: options.colorScheme || 'auto'
    },
    
    // ðŸŒ± TIMESTAMPS: Lifecycle tracking
    createdAt: Date.now(),
    updatedAt: Date.now(),
    lastAccessedAt: Date.now(),
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Project metadata (only when mode="project")
    project: options.mode === CREATIVE_MODES.PROJECT ? {
      name: options.projectName || null,
      description: options.projectDescription || null,
      tags: options.projectTags || [],
      deadline: options.projectDeadline || null,
      collaborators: options.projectCollaborators || [],
      status: options.projectStatus || 'active',
      priority: options.projectPriority || 'medium'
    } : null,
    
    // ðŸŒ± METADATA: Additional garden properties
    metadata: {
      // Original board context (if garden was created for existing board)
      originalBoardData: options.originalBoardData || null,
      
      // Migration information (if migrated from legacy board)
      migrationInfo: options.migrationInfo || null,
      
      // AI enhancement settings
      aiEnhancementEnabled: options.aiEnhancementEnabled !== false,
      aiSuggestionsEnabled: options.aiSuggestionsEnabled !== false,
      
      // Collaboration settings (future)
      collaborationEnabled: options.collaborationEnabled || false,
      sharedWithUsers: options.sharedWithUsers || [],
      
      // Usage statistics
      sessionCount: 0,
      totalTimeSpent: 0,
      nodeCreationCount: 0,
      connectionCount: 0
    },
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Promotion history tracking
    promotionHistory: [
      {
        action: 'created_as_freestyle',
        timestamp: Date.now(),
        mode: options.mode || CREATIVE_MODES.FREESTYLE
      }
    ]
  };
};

// ðŸŒ± BIFLOW: Create the special General Mind Garden
export const createGeneralMindGarden = () => {
  return {
    // Special fixed ID for General Mind Garden
    id: GENERAL_MIND_GARDEN.ID,
    
    // ðŸš¨ SPECIAL EXCEPTION: General Mind Garden has NO board (null allowed ONLY here)
    boardId: null,
    
    // Special origin for General Garden
    origin: BIFLOW_ORIGINS.GENERAL,
    
    // ðŸŽ¯ FREESTYLE TO PROJECT: Always freestyle (never promoted to project)
    mode: CREATIVE_MODES.FREESTYLE,
    
    // No parent (it's the root)
    parentGardenId: null,
    
    // Initial empty elements
    elements: [],
    
    // Layout configuration
    layout: {
      nodes: [],
      edges: [],
      viewport: { x: 0, y: 0, zoom: 1 },
      layoutType: 'organic',
      autoLayout: true,
      theme: 'default',
      colorScheme: 'auto'
    },
    
    // Timestamps
    createdAt: Date.now(),
    updatedAt: Date.now(),
    lastAccessedAt: Date.now(),
    
    // Special metadata for General Garden
    metadata: {
      isGeneralGarden: true, // Special flag
      title: GENERAL_MIND_GARDEN.TITLE,
      description: GENERAL_MIND_GARDEN.DESCRIPTION,
      
      // Cannot be deleted
      isDeletable: false,
      
      // Always visible in navigation
      isAlwaysVisible: true,
      
      // AI enhancement enabled by default
      aiEnhancementEnabled: true,
      aiSuggestionsEnabled: true,
      
      // No collaboration (it's personal)
      collaborationEnabled: false,
      sharedWithUsers: [],
      
      // Usage statistics
      sessionCount: 0,
      totalTimeSpent: 0,
      nodeCreationCount: 0,
      connectionCount: 0,
      
      // Promotion statistics
      totalPromotions: 0,
      boardsCreated: []
    }
  };
};

// ðŸŽ¯ FREESTYLE TO PROJECT: Promotion/Demotion utilities
export const freestyleProjectUtils = {
  /**
   * Promote creative space (board or garden) from freestyle to project
   */
  promoteToProject: (space, projectMetadata = {}) => {
    if (space.mode === CREATIVE_MODES.PROJECT) {
      console.warn('Space is already a project:', space.id);
      return space;
    }
    
    // Special case: General Mind Garden cannot be promoted
    if (space.id === GENERAL_MIND_GARDEN.ID || space.metadata?.isGeneralGarden) {
      throw new Error('General Mind Garden cannot be promoted to project');
    }
    
    const promotedSpace = {
      ...space,
      mode: CREATIVE_MODES.PROJECT,
      project: {
        name: projectMetadata.name || null,
        description: projectMetadata.description || null,
        tags: projectMetadata.tags || [],
        deadline: projectMetadata.deadline || null,
        collaborators: projectMetadata.collaborators || [],
        status: projectMetadata.status || 'active',
        priority: projectMetadata.priority || 'medium'
      },
      biflowUpdatedAt: Date.now(),
      promotionHistory: [
        ...space.promotionHistory,
        {
          action: 'promoted_to_project',
          timestamp: Date.now(),
          projectName: projectMetadata.name,
          previousMode: CREATIVE_MODES.FREESTYLE
        }
      ]
    };
    
    console.log('âœ… Space promoted to project:', space.id, 'â†’', projectMetadata.name);
    return promotedSpace;
  },
  
  /**
   * Demote creative space from project back to freestyle
   */
  demoteToFreestyle: (space, preserveProjectData = false) => {
    if (space.mode === CREATIVE_MODES.FREESTYLE) {
      console.warn('Space is already freestyle:', space.id);
      return space;
    }
    
    const demotedSpace = {
      ...space,
      mode: CREATIVE_MODES.FREESTYLE,
      project: preserveProjectData ? space.project : null,
      biflowUpdatedAt: Date.now(),
      promotionHistory: [
        ...space.promotionHistory,
        {
          action: 'demoted_to_freestyle',
          timestamp: Date.now(),
          previousMode: CREATIVE_MODES.PROJECT,
          preservedProjectData: preserveProjectData
        }
      ]
    };
    
    console.log('âœ… Space demoted to freestyle:', space.id);
    return demotedSpace;
  },
  
  /**
   * Bulk promote multiple spaces to a single project
   */
  bulkPromoteToProject: (spaces, projectMetadata = {}) => {
    return spaces.map(space => freestyleProjectUtils.promoteToProject(space, projectMetadata));
  },
  
  /**
   * Check if space can be promoted to project
   */
  canPromoteToProject: (space) => {
    // General Mind Garden cannot be promoted
    if (space.id === GENERAL_MIND_GARDEN.ID || space.metadata?.isGeneralGarden) {
      return { canPromote: false, reason: 'General Mind Garden cannot be promoted' };
    }
    
    // Already a project
    if (space.mode === CREATIVE_MODES.PROJECT) {
      return { canPromote: false, reason: 'Already a project' };
    }
    
    return { canPromote: true, reason: null };
  },
  
  /**
   * Get project summary from space
   */
  getProjectSummary: (space) => {
    if (space.mode !== CREATIVE_MODES.PROJECT || !space.project) {
      return null;
    }
    
    return {
      name: space.project.name,
      description: space.project.description,
      status: space.project.status,
      priority: space.project.priority,
      tags: space.project.tags,
      collaborators: space.project.collaborators?.length || 0,
      createdAt: space.createdAt,
      promotedAt: space.promotionHistory.find(h => h.action === 'promoted_to_project')?.timestamp
    };
  },
  
  /**
   * Generate smart project name suggestion
   */
  suggestProjectName: (space) => {
    // Try to extract meaningful name from content
    if (space.title) {
      return space.title;
    }
    
    if (space.type === 'board' && space.data?.title) {
      return space.data.title;
    }
    
    if (space.elements?.length > 0) {
      const firstElement = space.elements[0];
      if (firstElement.content) {
        const firstLine = firstElement.content.split('\n')[0];
        return firstLine.length > 30 ? firstLine.substring(0, 27) + '...' : firstLine;
      }
    }
    
    // Fallback to space type and date
    const date = new Date(space.createdAt).toLocaleDateString();
    return `${space.type === 'mindGarden' ? 'Ideas' : 'Board'} ${date}`;
  }
};

// ðŸŒ± BIFLOW: Validation helpers
export const biflowValidation = {
  /**
   * Validate that a board has a valid Mind Garden relationship
   * âš ï¸ EXCEPTION: Does not apply to General Mind Garden validation
   */
  validateBoardGardenLink: (board, garden) => {
    const errors = [];
    
    // ðŸš¨ SPECIAL CASE: Skip validation for General Mind Garden
    if (garden.id === GENERAL_MIND_GARDEN.ID || garden.metadata?.isGeneralGarden) {
      // General Mind Garden should NOT have a board
      if (garden.boardId !== null) {
        errors.push('BIFLOW_VIOLATION: General Mind Garden should have boardId: null');
      }
      return {
        isValid: errors.length === 0,
        errors,
        isGeneralGarden: true
      };
    }
    
    // Standard validation for dedicated gardens
    if (!board.mindGardenId) {
      errors.push('BIFLOW_VIOLATION: Board missing mindGardenId');
    }
    
    if (!garden.boardId) {
      errors.push('BIFLOW_VIOLATION: Dedicated garden missing boardId');
    }
    
    // Check bidirectional link
    if (board.mindGardenId !== garden.id) {
      errors.push('BIFLOW_VIOLATION: Board mindGardenId does not match garden id');
    }
    
    if (garden.boardId !== board.id) {
      errors.push('BIFLOW_VIOLATION: Garden boardId does not match board id');
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      isGeneralGarden: false
    };
  },
  
  /**
   * Check for orphaned entities (boards without gardens or gardens without boards)
   * âš ï¸ EXCEPTION: General Mind Garden (id='general') is allowed to have boardId: null
   */
  findOrphanedEntities: (boards, gardens) => {
    const orphanedBoards = boards.filter(board => 
      !board.mindGardenId || !gardens.find(garden => garden.id === board.mindGardenId)
    );
    
    // ðŸš¨ CRITICAL: Filter out General Mind Garden from orphan check
    const orphanedGardens = gardens.filter(garden => {
      // Special exception: General Mind Garden is allowed to be "orphaned"
      if (garden.id === GENERAL_MIND_GARDEN.ID || garden.metadata?.isGeneralGarden) {
        return false;
      }
      
      // All other gardens must have a valid board
      return !garden.boardId || !boards.find(board => board.id === garden.boardId);
    });
    
    return {
      orphanedBoards,
      orphanedGardens,
      hasOrphans: orphanedBoards.length > 0 || orphanedGardens.length > 0
    };
  },
  
  /**
   * Validate parent-child relationships
   */
  validateHierarchy: (boards, gardens) => {
    const errors = [];
    
    // Check for circular references in boards
    boards.forEach(board => {
      if (board.parentBoardId && board.parentBoardId === board.id) {
        errors.push(`HIERARCHY_VIOLATION: Board ${board.id} references itself as parent`);
      }
    });
    
    // Check for circular references in gardens
    gardens.forEach(garden => {
      if (garden.parentGardenId && garden.parentGardenId === garden.id) {
        errors.push(`HIERARCHY_VIOLATION: Garden ${garden.id} references itself as parent`);
      }
    });
    
    // Check hierarchy consistency (board parent should match garden parent)
    boards.forEach(board => {
      const garden = gardens.find(g => g.id === board.mindGardenId);
      if (garden) {
        const parentBoard = boards.find(b => b.id === board.parentBoardId);
        const parentGarden = gardens.find(g => g.id === garden.parentGardenId);
        
        if (parentBoard && parentGarden) {
          if (parentBoard.mindGardenId !== parentGarden.id) {
            errors.push(`HIERARCHY_VIOLATION: Board-Garden parent hierarchy mismatch for ${board.id}`);
          }
        }
      }
    });
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// ðŸŒ± BIFLOW: Migration utilities for legacy boards
export const biflowMigration = {
  /**
   * Create empty Mind Garden for legacy board without one
   */
  createGardenForLegacyBoard: (board) => {
    return createMindGarden(board.id, {
      origin: BIFLOW_ORIGINS.MIGRATED,
      migrationInfo: {
        migratedAt: Date.now(),
        originalBoard: {
          id: board.id,
          type: board.type,
          title: board.title || board.data?.title,
          createdAt: board.createdAt
        }
      },
      // Pre-populate with basic idea node if board has content
      elements: board.data?.description ? [{
        id: `idea_${Date.now()}_migration`,
        type: 'note',
        content: board.data.description,
        position: { x: 100, y: 100 },
        metadata: {
          migratedFromBoard: true,
          originalBoardId: board.id
        }
      }] : []
    });
  },
  
  /**
   * Update legacy board to include Mind Garden reference
   */
  updateLegacyBoardWithGarden: (board, garden) => {
    return {
      ...board,
      mindGardenId: garden.id,
      origin: BIFLOW_ORIGINS.MANUAL, // Assume manual creation for legacy
      biflowCreatedAt: Date.now(),
      biflowUpdatedAt: Date.now(),
      biflowMetadata: {
        promotionContext: null,
        promotedElementIds: [],
        sourceGardenId: null,
        autoGeneratedTitle: null,
        generation: 0,
        migrationInfo: {
          migratedAt: Date.now(),
          wasMigrated: true,
          originalCreatedAt: board.createdAt
        }
      }
    };
  },
  
  /**
   * Batch migrate all legacy boards
   */
  batchMigrateLegacyBoards: (boards, gardens) => {
    const legacyBoards = boards.filter(board => !board.mindGardenId);
    const newGardens = [];
    const updatedBoards = [];
    
    legacyBoards.forEach(board => {
      // Create garden for this board
      const garden = biflowMigration.createGardenForLegacyBoard(board);
      newGardens.push(garden);
      
      // Update board with garden reference
      const updatedBoard = biflowMigration.updateLegacyBoardWithGarden(board, garden);
      updatedBoards.push(updatedBoard);
    });
    
    return {
      migratedCount: legacyBoards.length,
      newGardens,
      updatedBoards,
      migrationSummary: {
        totalBoards: boards.length,
        legacyBoards: legacyBoards.length,
        newGardensCreated: newGardens.length,
        boardsUpdated: updatedBoards.length,
        migratedAt: Date.now()
      }
    };
  }
};

// ðŸŒ± BIFLOW: Promotion utilities (Mind Garden â†’ Board)
export const biflowPromotion = {
  /**
   * Generate smart title from promoted elements
   */
  generateTitleFromElements: (elements) => {
    if (elements.length === 0) return 'New Board';
    
    // Try to extract meaningful title from first element
    const firstElement = elements[0];
    
    if (firstElement.type === 'note' && firstElement.content) {
      // Use first line or first 30 characters
      const firstLine = firstElement.content.split('\n')[0];
      const title = firstLine.length > 30 ? firstLine.substring(0, 27) + '...' : firstLine;
      return title || 'New Board';
    }
    
    if (firstElement.title) {
      return firstElement.title;
    }
    
    // Fallback: descriptive title based on element types
    const typeCount = {};
    elements.forEach(el => {
      typeCount[el.type] = (typeCount[el.type] || 0) + 1;
    });
    
    const types = Object.keys(typeCount);
    if (types.length === 1) {
      const type = types[0];
      const count = typeCount[type];
      return count === 1 ? `${type} Board` : `${type}s Board (${count})`;
    } else {
      return `Mixed Board (${elements.length} items)`;
    }
  },
  
  /**
   * Create board from Mind Garden elements
   */
  promoteElementsToBoard: (elements, sourceGardenId, options = {}) => {
    const autoTitle = biflowPromotion.generateTitleFromElements(elements);
    
    // Calculate bounding box for promoted elements
    const bounds = biflowPromotion.calculateElementsBounds(elements);
    const boardPosition = bounds ? { x: bounds.x - 50, y: bounds.y - 100 } : { x: 100, y: 100 };
    
    // Create board
    const board = createBiFlowBoard(ELEMENT_TYPES.BOARD, boardPosition, {
      origin: sourceGardenId === 'mg-generale' ? BIFLOW_ORIGINS.MIND_GARDEN_GENERAL : BIFLOW_ORIGINS.SUB_BOARD,
      promotionContext: {
        sourceGardenId,
        promotedAt: Date.now(),
        elementsPromoted: elements.length,
        elementTypes: [...new Set(elements.map(el => el.type))]
      },
      promotedElementIds: elements.map(el => el.id),
      sourceGardenId,
      autoGeneratedTitle: autoTitle,
      generation: options.generation || 0
    });
    
    // Set generated title
    board.title = options.customTitle || autoTitle;
    board.data.title = board.title;
    board.data.description = options.description || `Promoted from Mind Garden with ${elements.length} elements`;
    
    // Create dedicated Mind Garden for this board
    const dedicatedGarden = createMindGarden(board.id, {
      origin: BIFLOW_ORIGINS.PROMOTED,
      elements: elements.map(el => ({
        ...el,
        // Mark as promoted
        metadata: {
          ...el.metadata,
          promotedFromGarden: sourceGardenId,
          promotedAt: Date.now()
        }
      })),
      originalBoardData: {
        autoGeneratedTitle: autoTitle,
        promotionContext: board.biflowMetadata.promotionContext
      }
    });
    
    // Link board to garden
    board.mindGardenId = dedicatedGarden.id;
    
    return {
      board,
      dedicatedGarden,
      promotionSummary: {
        sourceGardenId,
        elementsPromoted: elements.length,
        autoGeneratedTitle: autoTitle,
        promotedAt: Date.now()
      }
    };
  },
  
  /**
   * Calculate bounding box of elements for positioning
   */
  calculateElementsBounds: (elements) => {
    if (elements.length === 0) return null;
    
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    
    elements.forEach(element => {
      const x = element.position?.x || 0;
      const y = element.position?.y || 0;
      const width = element.size?.width || 200;
      const height = element.size?.height || 150;
      
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + width);
      maxY = Math.max(maxY, y + height);
    });
    
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
};

// ðŸŒ± BIFLOW: Navigation utilities
export const biflowNavigation = {
  /**
   * Get navigation path for board hierarchy
   */
  getBoardNavigationPath: (board, allBoards) => {
    const path = [];
    let currentBoard = board;
    
    while (currentBoard) {
      path.unshift({
        id: currentBoard.id,
        title: currentBoard.title || currentBoard.data?.title || 'Untitled Board',
        origin: currentBoard.origin
      });
      
      if (currentBoard.parentBoardId) {
        currentBoard = allBoards.find(b => b.id === currentBoard.parentBoardId);
      } else {
        break;
      }
    }
    
    return path;
  },
  
  /**
   * Get Mind Garden navigation path
   */
  getGardenNavigationPath: (garden, allGardens, allBoards) => {
    const path = [];
    let currentGarden = garden;
    
    while (currentGarden) {
      const associatedBoard = allBoards.find(b => b.id === currentGarden.boardId);
      
      path.unshift({
        gardenId: currentGarden.id,
        boardId: currentGarden.boardId,
        title: associatedBoard?.title || associatedBoard?.data?.title || 'Untitled Garden',
        origin: currentGarden.origin
      });
      
      if (currentGarden.parentGardenId) {
        currentGarden = allGardens.find(g => g.id === currentGarden.parentGardenId);
      } else {
        break;
      }
    }
    
    return path;
  }
};

// ðŸŒ± BIFLOW: Performance optimization utilities
export const biflowPerformance = {
  /**
   * Lazy load Mind Garden content
   */
  createGardenProxy: (gardenId, loadFunction) => {
    return new Proxy({}, {
      get(target, prop) {
        if (!target._loaded) {
          target._data = loadFunction(gardenId);
          target._loaded = true;
        }
        return target._data[prop];
      }
    });
  },
  
  /**
   * Debounced BiFlow sync
   */
  createDebouncedSync: (syncFunction, delay = 300) => {
    let timeoutId;
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => syncFunction(...args), delay);
    };
  }
};

// ðŸŒ± BIFLOW: Export all utilities
export const biflowUtils = {
  validation: biflowValidation,
  migration: biflowMigration,
  promotion: biflowPromotion,
  navigation: biflowNavigation,
  performance: biflowPerformance,
  freestyleProject: freestyleProjectUtils  // ðŸŽ¯ NEW: Freestyle to Project utilities
};